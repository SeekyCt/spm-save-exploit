# Copyright 2010 Dolphin Emulator Project
# Licensed under GPLv2+

# Copyright 2007,2008  Segher Boessenkool  <segher@kernel.crashing.org>
# Licensed under the terms of the GNU GPL, version 2
# http://www.gnu.org/licenses/old-licenses/gpl-2.0.txt

# Ported to Python by Seeky

from copy import deepcopy
from random import randint
import bn

def dumpBytes(b):
    for i in range(0, len(b)):
        if i % 8 == 0 and i > 0:
           print('')
        print(f"{b[i]:02x} ", end='')
    print('')

square = [0x00, 0x01, 0x04, 0x05, 0x10, 0x11, 0x14, 0x15,
          0x40, 0x41, 0x44, 0x45, 0x50, 0x51, 0x54, 0x55]

class Elt():
    def __init__(self):
        self.data = bytearray(30)

    def isZero(self):
        for d in self.data:
            if d != 0:
                return False
        return True

    def mulX(self):
        carry = self.data[0] & 1
        x = 0
        for i in range(0, len(self.data) - 1):
            y = self.data[i + 1]
            self.data[i] = (x ^ (y >> 7)) & 0xff
            x = (y << 1) & 0xff
        self.data[29] = x ^ carry
        self.data[20] ^= (carry << 2) & 0xff
    
    def square(self):
        wide = bytearray(60)
        for i in range(0, len(self.data)):
            wide[2 * i] = square[self.data[i] >> 4]
            wide[2 * i + 1] = square[self.data[i] & 15]
        for i in range(0, len(self.data)):
          x = wide[i]
          wide[i + 19] ^= x >> 7
          wide[i + 20] ^= (x << 1) & 0xff
          wide[i + 29] ^= x >> 1
          wide[i + 30] ^= (x << 7) & 0xff
        
        x = wide[30] & ~1
        wide[49] ^= x >> 7
        wide[50] ^= (x << 1) & 0xff
        wide[59] ^= x >> 1
        wide[30] &= 1

        ret = Elt()
        ret.data = wide[30:]
        return ret
      
    def itohTsujii(self, b, j):
        t = Elt()
        t.data = self.data[:]
        while j != 0:
            t = t.square()
            j -= 1
        return t.mult(b)
      
    def inv(self):
        t = self.itohTsujii(self, 1)
        s = t.itohTsujii(self, 1)
        t = s.itohTsujii(s, 3)
        s = t.itohTsujii(self, 1)
        t = s.itohTsujii(s, 7)
        s = t.itohTsujii(t, 14)
        t = s.itohTsujii(self, 1)
        s = t.itohTsujii(t, 29)
        t = s.itohTsujii(s, 58)
        s = t.itohTsujii(t, 116)
        return s.square()

    def add(self, b):
        d = Elt()
        for i in range(0, 30):
            d.data[i] = self.data[i] ^ b.data[i]
        return d

    def mult(self, b):
        d = Elt()
        i = 0
        mask = 1
        for n in range(0, 233):
            d.mulX()
            if (self.data[i] & mask) != 0:
                d = d.add(b)
            mask >>= 1
            if mask == 0:
                mask = 0x80
                i += 1
        return d
    
    def div(self, b):
        return self.mult(b.inv())

class Point:
    def __init__(self):
        self.x = Elt()
        self.y = Elt()
    
    def init_copy(self, data):
        self.x.data = data[:30]
        self.y.data = data[30:60]

    def init_copy2(self, eltX, eltY):
        self.x.data = eltX.data[:]
        self.y.data = eltY.data[:]
      
    def isZero(self):
        return self.x.isZero() and self.y.isZero()

    def double(self):
        r = Point()
        if self.x.isZero():
            return r
        s = self.y.div(self.x).add(self.x)
        r.x = s.square().add(s)
        r.x.data[29] ^= 1
        r.y = s.mult(r.x).add(r.x).add(self.x.square())
        return r

    def add(self, b):
        if self.isZero():
            return deepcopy(b)
        if b.isZero():
            return deepcopy(self)
        
        u = self.x.add(b.x)
        if u.isZero():
            u = self.y.add(b.y)
            if u.isZero():
                return self.double()
            return Point()
        
        s = self.y.add(b.y).div(u)
        t = s.square().add(s).add(b.x)
        t.data[29] ^= 1
        rx = t.add(self.x)
        ry = s.mult(t).add(self.y).add(rx)
        ret = Point()
        ret.init_copy2(rx, ry)
        return ret

def pointMult(a, b):
    d = Point()
    for i in range(0, 30):
        mask = 0x80
        while mask != 0:
            d = d.double()
            if (a[i] & mask):
                d = d.add(b)
            mask >>= 1
    return d


# order of the addition group of points
ec_N = bytearray([
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x13, 0xe9, 0x74, 0xe7, 0x2f,
    0x8a, 0x69, 0x22, 0x03, 0x1d, 0x26, 0x03, 0xcf, 0xe0, 0xd7
])

# base point
ec_G = Point()
ec_G.init_copy([
    # X
    0x00, 0xfa, 0xc9, 0xdf, 0xcb, 0xac, 0x83, 0x13, 0xbb, 0x21, 0x39, 0xf1, 0xbb, 0x75, 0x5f,
    0xef, 0x65, 0xbc, 0x39, 0x1f, 0x8b, 0x36, 0xf8, 0xf8, 0xeb, 0x73, 0x71, 0xfd, 0x55, 0x8b,

    # Y
    0x01, 0x00, 0x6a, 0x08, 0xa4, 0x19, 0x03, 0x35, 0x06, 0x78, 0xe5, 0x85, 0x28, 0xbe, 0xbf,
    0x8a, 0x0b, 0xef, 0xf8, 0x67, 0xa7, 0xca, 0x36, 0x71, 0x6f, 0x7e, 0x01, 0xf8, 0x10, 0x52
])

def sign(key, hash):
    e = bytearray(30)
    e[10:] = hash[:20]

    m = bytearray(30)
    while True:
        for i in range(0, 30):
            m[i] = randint(0, 0xff)
        m[0] &= 1
        if bn.compare(m, ec_N, 30) < 0:
            break
    
    r = pointMult(m, ec_G).x
    if bn.compare(r.data, ec_N, 30) >= 0:
        bn.sub_modulus(r.data, ec_N, 30)

    #	S = m**-1*(e + Rk) (mod N)

    kk = bytearray(30)
    kk = key[:30]
    if bn.compare(kk, ec_N, 30) >= 0:
        bn.sub_modulus(kk, ec_N, 30)

    s = Elt()
    bn.mul(s.data, r.data, kk, ec_N, 30)
    bn.add(kk, s.data, e, ec_N, 30)

    minv = bytearray(30)
    bn.inv(minv, m, ec_N, 30)
    bn.mul(s.data, minv, kk, ec_N, 30)

    signature = bytearray(60)
    signature[:30] = r.data[:]
    signature[30:] = s.data[:]
    return signature

def verifySignature(publicKey, signature, hash):
    R = signature[:30]
    S = signature[30:]

    Sinv = bytearray(30)
    bn.inv(Sinv, S, ec_N, 30)
    e = bytearray(30)
    e[10:] = hash[:20]

    w1 = bytearray(30)
    w2 = bytearray(30)
    bn.mul(w1, e, Sinv, ec_N, 30)
    bn.mul(w2, R, Sinv, ec_N, 30)

    publicKeyPoint = Point()
    publicKeyPoint.init_copy(publicKey)
    r1 = pointMult(w1, ec_G).add(pointMult(w2, publicKeyPoint))
    rx = r1.x.data
    if bn.compare(rx, ec_N, 30) >= 0:
        bn.sub_modulus(rx, ec_N, 30)
        
    return bn.compare(rx, R, 30) == 0

def privToPub(key):
    data = pointMult(key, ec_G)
    result = bytearray(60)
    result[:30] = data.x.data[:]
    result[30:] = data.y.data[:]
    return result
