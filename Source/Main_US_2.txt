# SPDX-License-Identifier: GPL-3.0-or-later
# Copyright 2020 Linus S. (aka PistonMiner)

# Modifications made by Zephiles

# Set global function/variable/offset locations/values
.set LOADER_SIZE,(__end - __start)
.set LOADER_ARENA_LOCATION,0x81000000
.set LOADER_LOWMEM_LOCATION,0x80000F98

.set SAVE_REGION_START_OFFSET,-0x7390
.set SAVE_REGION_END_OFFSET,-0x738C

.set PAYLOAD_HOOK_LOCATION,0x8023CA18

.set wiiResetCode,0x801A7BC4
.set __OSReboot,0x80273BE8
.set Run_main,0x8026F338
.set Run_restart,0x81333B28

.set relIsLoadedBoolCheck,0x8023CA20

.set memmove,0x802587C4
.set DCFlushRange,0x8026DFA0
.set ICInvalidateRange,0x8026E028

.set relWpOffset,-0x7D60
.set NANDOpen,0x80298318
.set NANDRead,0x80297AC4
.set OSLink,0x80272B5C
.set __memAlloc,0x801A59A8
.set __memFree,0x801A5A2C
.set OSUnlink,0x80272DA0
.set NANDClose,0x80298598

__start:
# Hook __OSReboot
lis r3,__OSReboot@h
ori r3,r3,__OSReboot@l
bl main_pic

main_pic:
mflr r4
addi r4,r4,(__OSReboot_hook - main_pic)
bl writeBranch

# Branch to wiiResetCode without returning
lis r3,wiiResetCode@h
ori r3,r3,wiiResetCode@l
mtctr r3
bctr

# Runs out of initial location. Relocates to arena location, sets saved region
# and patches Run in game binary.
__OSReboot_hook:
stwu sp,-0x20(sp)
mflr r0
stw r0,0x24(sp)
stmw r29,0x8(sp)

# Save arguments for original function
mr r30,r3
mr r31,r4

# Initialize static values used for addresses
lis r29,LOADER_ARENA_LOCATION@h

# Relocate into arena memory
mr r3,r29 # LOADER_ARENA_LOCATION
bl __OSReboot_hook_pic

__OSReboot_hook_pic:
mflr r4
addi r4,r4,(__start - __OSReboot_hook_pic)
li r5,LOADER_SIZE
lis r12,memmove@h
ori r12,r12,memmove@l
mtlr r12
blrl

mr r3,r29 # LOADER_ARENA_LOCATION
li r4,LOADER_SIZE
bl makeCodeChangesVisible

# Set the saved region start and end
stw r29,SAVE_REGION_START_OFFSET(r13)
addi r3,r29,LOADER_SIZE
stw r3,SAVE_REGION_END_OFFSET(r13)

# Set up Run hook in main binary
lis r3,Run_main@h
ori r3,r3,Run_main@l
ori r4,r29,(LOADER_ARENA_LOCATION + (Run_main_hook - __start))@l
bl writeBranch

# Back into __OSReboot
lis r3,(__OSReboot + 4)@h
ori r12,r3,(__OSReboot + 4)@l
mtctr r12

# Restore arguments for original function
mr r3,r30
mr r4,r31

lmw r29,0x8(sp)
lwz r0,0x24(sp)
mtlr r0
addi sp,sp,0x20
bctr

# Runs out of arena location. Called when restart binary is about to be
# executed. Patch restart binary.
Run_main_hook:
# This is just before loading a new DOL which will reset everything, so we
# don't need to worry about preserving register contents

# Save entrypoint
mr r31,r3

# Set up Run hook in restart DOL
lis r3,Run_restart@h
ori r3,r3,Run_restart@l
lis r4,(LOADER_ARENA_LOCATION + (Run_restart_hook - __start))@h
ori r4,r4,(LOADER_ARENA_LOCATION + (Run_restart_hook - __start))@l
bl writeBranch

# Restore entrypoint
mr r3,r31

# Back into Run
b ((Run_main + 4) - LOADER_ARENA_LOCATION + __start)

# Runs out of arena location. Called when game binary is about to be executed.
# Relocates to low memory and patches reloaded game DOL.
Run_restart_hook:
# This is just before loading a new DOL which will reset everything, so we
# don't need to worry about preserving register contents

# Save entrypoint
mr r31,r3

# Relocate to low memory
lis r30,LOADER_LOWMEM_LOCATION@h
ori r3,r30,LOADER_LOWMEM_LOCATION@l
lis r4,LOADER_ARENA_LOCATION@h
li r5,LOADER_SIZE
bl (memmove - LOADER_ARENA_LOCATION + __start)

ori r3,r30,LOADER_LOWMEM_LOCATION@l
li r4,LOADER_SIZE
bl makeCodeChangesVisible

# Place hook for payload
lis r3,PAYLOAD_HOOK_LOCATION@h
ori r3,r3,PAYLOAD_HOOK_LOCATION@l
ori r4,r30,(LOADER_LOWMEM_LOCATION + (gPayload - __start))@l
bl writeBranch

# Place restart hook
lis r3,__OSReboot@h
ori r3,r3,__OSReboot@l
lis r4,(LOADER_LOWMEM_LOCATION + (__OSReboot_hook - __start))@h
ori r4,r4,(LOADER_LOWMEM_LOCATION + (__OSReboot_hook - __start))@l
bl writeBranch

# Change relIsLoaded to check the bool at 0x9 instead of 0x8
lis r3,relIsLoadedBoolCheck@h
ori r3,r3,relIsLoadedBoolCheck@l
li r4,9
stb r4,0x3(r3)
bl makeWordChangeVisible

# Restore entrypoint
mr r3,r31

# Back into Run
b ((Run_restart + 4) - LOADER_ARENA_LOCATION + __start)

writeBranch:
# Write instruction
subf r4,r3,r4
rlwinm r4,r4,0,6,29
lis r5,0x4800
or r5,r5,r4
stw r5,0(r3)

# Make visible, tailcall
makeWordChangeVisible:
li r4,4

makeCodeChangesVisible:
stwu sp,-0x20(sp)
mflr r0
stw r0,0x24(sp)
stmw r29,0x8(sp)

mr r31,r3 # address
mr r30,r4 # size

lis r29,DCFlushRange@h
ori r5,r29,DCFlushRange@l
mtlr r5
blrl

ori r3,r29,ICInvalidateRange@l
mtlr r3
mr r3,r31 # address
mr r4,r30 # size
blrl

lmw r29,0x8(sp)
lwz r0,0x24(sp)
mtlr r0
addi sp,sp,0x20
blr

gPayload:
# Original REL Loader code by SeekyCt, with various modifications by Zephiles
# If the custom rel is loaded, then exit
lwz r3,relWpOffset(r13)
lbz r0,0x9(r3)
cmpwi r0,0
bnelr+

# If the game's rel is not loaded, then exit
lbz r0,0x8(r3)
cmpwi r0,0
beqlr-

# Push stack
stwu sp,-0x20(sp)
mflr r0
stw r0,0x24(sp)
stmw r27,0x8(sp)

# Initialize static values used for addresses
lis r31,0x8000
li r30,0 # Used to check if a REL file is loaded or not

# Allocate memory for NANDFileInfo
li r4,0x8C
bl allocateMemory

# Backup the returned address to be used for later
mr r29,r3

# Open the file
ori r3,r31,(LOADER_LOWMEM_LOCATION + filenameString)@l
mr r4,r29 # Pointer to NANDFileInfo
li r5,1 # NAND_ACCESS_READ
bl (NANDOpen - LOADER_LOWMEM_LOCATION + __start)
cmpwi r3,0 # Check if something went wrong
bne- freeNandFileInfo

# Allocate 0x20 bytes of memory, as the read size must be in multiples of 0x20 bytes
li r4,0x20 # Bytes to allocate
bl allocateMemory

# Backup the returned address to be used for later
mr r27,r3

# Read from the NAND
mr r3,r29 # Pointer to NANDFileInfo
mr r4,r27 # Pointer to the File Buffer
li r5,0x20 # Amount of bytes to read
bl (NANDRead - LOADER_LOWMEM_LOCATION + __start)
cmpwi r3,0 # Check if something went wrong
blt- freeCurrentMemoryArea

# Get the file size and adjust it to be in multiples of 0x20 bytes
lwz r28,0(r27) # File Size
addi r28,r28,31
rlwinm r28,r28,0,0,26

# Free the 0x20 bytes from earlier
mr r4,r27
bl freeMemory

# Allocate more bytes based on the adjusted file size
mr r4,r28
bl allocateMemory

# Backup the returned address to be used for later
mr r27,r3

# Read the REL Area of the file
# NANDRead automatically seeks to the next section
mr r3,r29 # Pointer to NANDFileInfo
mr r4,r27 # Pointer to the File Buffer
mr r5,r28 # Adjusted File Size
bl (NANDRead - LOADER_LOWMEM_LOCATION + __start)
cmpwi r3,0 # Check if something went wrong
blt- freeCurrentMemoryArea

# Get the BSS Area size and allocate memory for it
lwz r4,0x20(r27)
bl allocateMemory

# Backup the returned address to be used for later
mr r28,r3

# Link the functions in the REL
mr r3,r27 # Pointer to the Module
mr r4,r28 # Pointer to the BSS Area
bl (OSLink - LOADER_LOWMEM_LOCATION + __start)
cmpwi r3,1 # Check if something went wrong
bne- freeRemainingMemory

# Store the BSS Area and the Module
stw r28,0x13F8(r31) # Pointer to the BSS Area
stw r27,0x13FC(r31) # Pointer to the Module

# Get the REL Prolog Pointer
lwz r30,0x34(r27)

# Done, so close the file
b closeNand

# Function definitions, error handling, etc.
freeMemory:
li r3,0 # Heap to use
b (__memFree - LOADER_LOWMEM_LOCATION + __start)

allocateMemory:
li r3,0 # Heap to use
b (__memAlloc - LOADER_LOWMEM_LOCATION + __start)

freeRemainingMemory:
mr r3,r27 # Pointer to the Module
bl (OSUnlink - LOADER_LOWMEM_LOCATION + __start)

# Free the BSS Area and the File Buffer
mr r4,r28 # Pointer to the BSS Area
bl freeMemory

freeCurrentMemoryArea:
mr r4,r27 # Pointer to the File Buffer or the 0x20 Bytes Buffer
bl freeMemory

closeNand:
mr r3,r29 # Pointer to NANDFileInfo
bl (NANDClose - LOADER_LOWMEM_LOCATION + __start)

freeNandFileInfo:
mr r4,r29
bl freeMemory

# Run the REL Prolog if the load was successful
cmpwi r30,0
beq- exit
mtlr r30
blrl

exit:
# Stop this code from running again and let the game continue
lwz r3,relWpOffset(r13)
li r0,1
stb r0,0x9(r3)

# Pop stack
lmw r27,0x8(sp)
lwz r0,0x24(sp)
mtlr r0
addi sp,sp,0x20
blr

filenameString:
.asciz "pcrel.bin"

__end: